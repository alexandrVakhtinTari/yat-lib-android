/**
* Emoji ID API server
* Emoji ID is a directory service that associates almost any type of structured data with a short, memorable identifier the emoji id.
*
* The version of the OpenAPI document: 0.2.262
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package com.yatlabs.yat.apis

import com.yatlabs.yat.models.AcceptTransfer
import com.yatlabs.yat.models.DisplayTransferRequest
import com.yatlabs.yat.models.ListOfDisplayTransferRequest
import com.yatlabs.yat.models.TransferRequest

import com.yatlabs.yat.infrastructure.ApiClient
import com.yatlabs.yat.infrastructure.ClientException
import com.yatlabs.yat.infrastructure.ClientError
import com.yatlabs.yat.infrastructure.ServerException
import com.yatlabs.yat.infrastructure.ServerError
import com.yatlabs.yat.infrastructure.MultiValueMap
import com.yatlabs.yat.infrastructure.RequestConfig
import com.yatlabs.yat.infrastructure.RequestMethod
import com.yatlabs.yat.infrastructure.ResponseType
import com.yatlabs.yat.infrastructure.Success

class TransferApi : ApiClient() {

    companion object {
        // The shared singleton.
        val shared = TransferApi()
    }

    /**
    * Mark transfer request as deleted
    * Note: user expected to be Admin or creator of transfer request Note: When transfer request deleted it cannot be accepted, if it was accepted before being deleted it is just marked deleted, but emoji does not move back
    * @param transferId  
    * @return DisplayTransferRequest
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteTransfer(transferId: java.util.UUID) : DisplayTransferRequest {
        val localVariableBody: Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/transfers/{transfer_id}".replace("{"+"transfer_id"+"}", "$transferId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<DisplayTransferRequest>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DisplayTransferRequest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * List outgoing transfer requests for current or specified user If limit is omitted will display top 50 transfer requests
    * 
    * @param acceptedAfter When set will display only requests accepted after provided datetime (optional)
    * @param dir  (optional)
    * @param limit  (optional)
    * @param page  (optional)
    * @param senderId Uuid of a sender (optional)
    * @param sort  (optional)
    * @return ListOfDisplayTransferRequest
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listFiltered(acceptedAfter: java.time.OffsetDateTime?, dir: kotlin.String?, limit: kotlin.Int?, page: kotlin.Int?, senderId: java.util.UUID?, sort: kotlin.String?) : ListOfDisplayTransferRequest {
        val localVariableBody: Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (acceptedAfter != null) {
                    put("accepted_after", listOf(parseDateToQueryString(acceptedAfter)))
                }
                if (dir != null) {
                    put("dir", listOf(dir.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (senderId != null) {
                    put("sender_id", listOf(senderId.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/transfers",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<ListOfDisplayTransferRequest>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListOfDisplayTransferRequest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * List transfer requests assigned to user
    * 
    * @param accepted Display accepted transfer requests.  By default will display pending requests only. 
    * @return kotlin.collections.List<DisplayTransferRequest>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listIncoming(accepted: kotlin.Boolean) : kotlin.collections.List<DisplayTransferRequest> {
        val localVariableBody: Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("accepted", listOf(accepted.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/transfers/incoming",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<kotlin.collections.List<DisplayTransferRequest>>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<DisplayTransferRequest>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * As a receiver, accept transfer request by id.
    * If the OTP is correct, the transfer instructions are submitted. Returning transferred Emoji IDs
    * @param transferId  
    * @param body  
    * @return kotlin.collections.List<kotlin.String>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun receiverAcceptTransfer(transferId: java.util.UUID, body: AcceptTransfer) : kotlin.collections.List<kotlin.String> {
        val localVariableBody: Any? = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/transfers/{transfer_id}/receiver_accept".replace("{"+"transfer_id"+"}", "$transferId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<kotlin.collections.List<kotlin.String>>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.String>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Transfer eid to either the pubkey or email address supplied in the PUT data
    * Note: user expected to be Admin or have scope &#x60;Scopes::EmojiTransfer&#x60; and own emoji If recipient does not exist account will be created and sent invitation email If recipient is not activated it will be automatically activated
    * @param body  
    * @return DisplayTransferRequest
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun requestTransfer(body: TransferRequest) : DisplayTransferRequest {
        val localVariableBody: Any? = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/transfers",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<DisplayTransferRequest>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DisplayTransferRequest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Resend a new transfer OTP code for the current user, if the transfer allows it.
    * The code will be resent if: - the current user is the sender and the sender has not confirmed - the current user is the receiver, the sender has confirmed the transfer but has not been accepted by the receiver
    * @param transferId  
    * @return kotlin.Any
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun resendCode(transferId: java.util.UUID) : kotlin.Any {
        val localVariableBody: Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/transfers/{transfer_id}/resend_code".replace("{"+"transfer_id"+"}", "$transferId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<kotlin.Any>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * As a sender, confirm the transfer request by transfer id.
    * The correct OTP must be provided. If it is, the receiver is notified and may accept the transfer. Returning an empty response object on success
    * @param transferId  
    * @param body  
    * @return DisplayTransferRequest
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun senderAcceptTransfer(transferId: java.util.UUID, body: AcceptTransfer) : DisplayTransferRequest {
        val localVariableBody: Any? = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/transfers/{transfer_id}/sender_accept".replace("{"+"transfer_id"+"}", "$transferId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<DisplayTransferRequest>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DisplayTransferRequest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

}
